# 1.面向对象的基础知识
## 1.1 面向对象两个要素
 + 类：对一类事物的描述，是抽象的、概念上的定义  
 + 对象：是实际存在的该类食物的每个个体，因而也称为实例(instance)
## 1.2 类和对象的使用
 + 创建类，设计类的成员
 + 创建类的对象
 + 通过“对象”，调用类的属性或方法
 + 如果创建了一个类的多个对象，则每个对象都独立拥有一套类的属性(非static)
## 1.3 方法：描述类应该具有的功能 
1. 方法的声明：权限修饰符 返回值类型 方法名（参数列表）
2. 权限修饰符，java规定的4种权限修饰符（private,public,protected,缺省）
3. 返回值类型
   + 如果方法有返回值，则必须在方法声明时，指定返回值的类型，同时方法中需要使用“return”关键字返回指定类型的变量；
   + 如果方法没有返回值，声明方法时使用void来表示；
---


# 2.对象的创建与对象的内存解析
1. 编译完源程序以后，生成一个或多个字节码文件。我们使用JVM中的类的加载器和解释器对生成的字节码进行解释运行。意味着，需要将字节码文件对应的类加载到内存中，涉及到内存解析。可参考书籍《JVM规范》
2. 结构
 + 虚拟机栈：即为平时听到的栈结构。我们将局部变量存储在栈结构中；
 + 堆，将new出来的结构（数组、对象）加载字加载在堆空间中。补充：对象的属性（非static的）加载在堆空间中
---

# 3. 匿名对象的使用
+ 创建的对象，没有显示的付给一个变量名；
+ 匿名对象只能调用一次
---

# 4.方法
1. 方法的重载（overload）
 + 定义：允许存在一个以上的同名方法，只要他们的参数个数或者参数类型不同即可
 + 两同一不同：同一个类、同一个方法名。参数的列表、个数、类型不同；
 + 是否是重载和权限修饰符、返回值类型、方法体没有关系
---
2. 可变个数形参的方法（jdk5.0之后）
 + 格式 权限修饰符 返回值类型 方法名（参数类型...参数名称）。例：public void show(String...args)
 + 当调用可变个数形参的方法是，传入的参数个数可以是多个
 + 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载
 + 可变个数形参的方法与本类中方面相同，形参类型也相同的数组之间不构成重载
 + 可变个数形参在方法的形参中，必须写到参数的末尾；
 + 可变个数形参在方法的形参中，最多只能声明一个；
---
3. 方法参数的值传递进制
 + 如果变量是基本数据类型，此时赋值的是变量所保存的数据值；如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值
 + 如果参数是基本数据类型，此时实参赋给形参的是 
---
4. 递归方法(recursion)
 + 定义：一个方法体内调用他自身
 + 示例：求100之间所有数相加的和
  ```java
  public int  getSum(int n){
     if(n==1){
      return 1;
     }
     else{
      return n + getSum(n-1);
     }
  }
  ```
---
5. Java规定的4中权限
 + 从小到大排列：private 缺省 protected public
 + 权限说明
     |权限名称|类内部|同一个包下|不同包的子类|同一个工程|
     |-      |-     |-       |-           |-        |
     |private| √    |        |            |         |
     |缺省   |√     |√         |           |         |
     |protected|√    |√       |√          |          |
     |public|√      |√       |√           |√        |
 + 可以用来修饰类（只能有缺省、public）、类的内部结构（属性、方法、构造器、内部类)

---
6. 构造器的使用
 + 构造器的作用：创建对象、初始化对象的属性
 + 如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器
 + 定义构造器的格式：权限修饰符 类名（形参）{}

---
7. package和Import关键字的使用
 + package的使用
   + 为了更好的实现项目中类的管理，提供包的概念
   + 使用package声明类或接口所属的包，声明在源文件的首行
   + 包，属于标识符，遵循标识符的命名规则
   + 每“.”一次，就点一次文件目录
 + import关键字的使用
   + 在源文件中显式的使用import结构导入指定包下的类、接口
---
8. 继承
 + 关键字 extends 
   + class A extends B{}
   + A:子类、派生类
   + B：父类、超类
   + 一旦子类A继承父类B后，子类A就可以获取父类中所有的属性、结构、方法
   + 父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构，只是因为封装线的影响，使得子类不能直接调用父类的结构
   + 子类继承父类以后，还可以声明自己特有的属性或方法，实现功能的拓展；
 + java中关于继承性的规定
   + 一个类可以被多个子类继承；
   + 一个类只能有一个父类
   + 子父类是相对的概念
   + 子类直接继承的父类，称为：直接父类。间接继承的父类，称为间接父类；
   + 子类继承父类以后，就获取了直接附列以及所有间接父类中声明的属性或方法
 + 其他特性
   + 如果没有显式的声明一个类的父类的话，则此类继承与java.lang.Object类
   + 意味着，所有的java类都具有java.lang.Object类声明的功能
 + 继承性的好处
   + 减少代码的冗余，提供代码的复用性
   + 便于功能的扩展
   + 为多态性提供前提 
---
9. 重写（override/overwrite）
 + 定义
   在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法
 + 应用：重写以后，当创建子类对象以后，通过子类对象调用子父类对象中的同名参数的方法是，实际执行的是子类重写父类的方法
 + 重写的规定
   + 子类重写的方法的方法名和形参列表，与父类被重写的方法的方法名和形参列表相同。子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符
   + 特殊情况:子类不能重写父类中声明为private权限的方法返回值类型。
   + 父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void
   + 父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类
   + 父类被重写的方法的返回值类型是基本数据类型(比如。double)，则子类重写的方法的返回值类型必须是子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（具体放到异常处理时候讲)
---
10. super关键字
 + super理解为：父类的
 + super可以用来调用属性、方法、构造器
 + super的使用
  1. 可以在子类的方法或构造器中，通过使用super.属性的方式，显示的调用。
  2. 当子类和父类中定义了同名的属性时，想在子类中调用父类中声明的属性，则必须显示的使用super.属性的方式，表明调用的事父类中声明的属性 
---
11. 多态性
 + 多态性，可以理解为一个事物的多种形态；
 + 何多态性：父类的引用指向子类对象（或子类的对象赋给父类的引用） 
 + 多态的使用：虚拟方法调用。有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我什么实际执行的是子类重写父类的方法；总结：编译看左边，运行看右边；
 + 多态性的使用前提：
   + 类的继承关系
   + 子类中存在对父类方法的重写
 + 对象的多态性，只适用于方法，不用于属性
---
12. Object类（java.lang.Object类）
 + Object类是所有java类的根父类
 + 如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类
 + Object类中的功能（属性、方法）就具有通用性
   + 属性：无
   + 方法：equals() \ toString() \ getClass() \ hashCode() \ clone() \ finalize() \ wait() \ notify() \ notifyAll()
---
13.  ==和equals()的区别
 + == 运算符
   + 可以使用在基本数据类型变量和引用数据类型变量中
   + 如果比较的是基本数据类型变量，比较两个变量保存的数据是否相等（不 一定类型相同）
   + 如果比较的是引用数据类型，比较两个的地址值
 + equals()方法
   + 是一个方法，非运算符。仅能使用在引用数据类型
   + Object类中的equals()的定义，依然是使用的==。即比较两个值的地址值；
   + 部分类中（如String、Date等），将Object中的equals()方法进行了重写，仅比较两个变量保存的数据；
---
14. Object类中toString()的使用
 + 当我们输出一个对象的引用时，实际上就是调用当前对象的toString()方法；
 + 像String \ Data 等包装类，都重写了toString()方法。使得在调用对象的ToString()方法时，返回“实体内容”信息；
 + 自定义类也可以重新toString()方法，当调用此方法时，返回“实体内容”信息；
---
15. 单元测试 JUnit
 + 选择当前工程 - 右键选择 build path -  add libraries -JUnit
 + 创建Java类，进行单元测试
   + 此类是public
   + 此类提供公共的无参的构造器
 + 在类中声明单元测试方法
   + 此时的单元测试方法，方法的权限是public，没有返回值，没有形参
   + 此单元测试方法上需要声明注解：@Test。并在单元测试类中导入：import org.junit.Test
 + 写完代码后，左键双击单元测试方法名，右键：run as - JUnit XXX
---
16. 包装类(Wrapper)的使用
 + 针对八种基本数据类型定义相应的引用类型-包装类（封装类）
  |基本数据类型|包装类|
   |-         |-     |
   |byte      |Byte  |
   |short     |Short  |
   |int       |Integer|
   |long      |Long   |
   |float     |Float  |
   |double    |Double  |
   |boolean   |Boolean|
   |char      |Character|
---
17. static关键字（静态的）
 + 可以用来修饰：属性、方法、代码块、内部类
 + 使用static修饰的属性：静态变量。多个对象共享同一个静态变量  
 + static修饰属性的其他说明
   + 静态变量随着类的加载而加载，可以通过“类、静态变量"的方式调用
   + 静态变量的加载要早于对象的创建
   + 由于类只会加载一次，则静态变量在内存中也只会存在一份，存在方法区的静态域中
 + static修饰方法：静态方法
   + 随着类的加载而加载
---
18. abstract关键字（抽象的）
 + abstract修饰类：抽象类
   + 此类不能被实例化
   + 抽象类中一定有构造器，便于子类实例化时调用
   + 开发中，都会提供抽象类的子类，让子类对象实例化，完成相关操作
 + abstract修饰方法：抽象方法
   + 抽象方法只有方法的声明，没有方法体
   + 包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽闲方法的
   + 若子类重写了父类中的所有抽象方法后，此子类方可实例化
